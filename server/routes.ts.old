import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { lygosService } from "./lygos-service";
import { PayDunyaService } from "./paydunya-service";
import { paymentService } from "./payment-service";
import { 
  insertFavoriteSchema, 
  insertWatchHistorySchema, 
  insertUserPreferencesSchema, 
  insertContactMessageSchema, 
  insertUserSchema,
  insertSubscriptionSchema,
  insertPaymentSchema,
  insertBannerSchema,
  insertCollectionSchema,
  insertContentSchema,
  insertNotificationSchema,
  insertUserSessionSchema,
  insertViewTrackingSchema
} from "@shared/schema";
import { z } from "zod";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key-here";

// Initialize PayDunya service
const paydunyaService = new PayDunyaService();

// Authentication middleware
function authenticateToken(req: any, res: any, next: any) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    // For now, we'll allow requests without tokens but set user to null
    req.user = null;
    return next();
  }

  jwt.verify(token, JWT_SECRET, (err: any, user: any) => {
    if (err) {
      req.user = null;
    } else {
      req.user = user;
    }
    next();
  });
}

// Admin middleware
function requireAdmin(req: any, res: any, next: any) {
  if (!req.user) {
    return res.status(401).json({ error: "Non authentifié" });
  }
  
  // Check if user is admin by fetching from database
  storage.getUserById(req.user.userId).then(user => {
    if (!user || user.role !== "admin") {
      return res.status(403).json({ error: "Accès administrateur requis" });
    }
    next();
  }).catch(error => {
    console.error("Error checking admin status:", error);
    res.status(500).json({ error: "Erreur serveur" });
  });
}

// Login/Register schemas
const loginSchema = z.object({
  email: z.string().email("Email invalide"),
  password: z.string().min(6, "Le mot de passe doit contenir au moins 6 caractères")
});

const registerSchema = insertUserSchema.extend({
  password: z.string().min(6, "Le mot de passe doit contenir au moins 6 caractères"),
  confirmPassword: z.string()
}).refine((data) => data.password === data.confirmPassword, {
  message: "Les mots de passe ne correspondent pas",
  path: ["confirmPassword"]
});

export async function registerRoutes(app: Express): Promise<Server> {
  
  // Apply authentication middleware to all routes
  app.use(authenticateToken);
  
  // Authentication routes
  app.post("/api/auth/register", async (req, res) => {
    try {
      const userData = registerSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByEmail(userData.email);
      if (existingUser) {
        return res.status(400).json({ error: "Un utilisateur avec cet email existe déjà" });
      }
      
      // Hash password
      const hashedPassword = await bcrypt.hash(userData.password, 10);
      
      // Create user
      const user = await storage.createUser({
        username: userData.username,
        email: userData.email,
        password: hashedPassword
      });
      
      // Generate JWT token
      const token = jwt.sign(
        { userId: user.id, email: user.email, username: user.username },
        JWT_SECRET,
        { expiresIn: '7d' }
      );
      
      // Return user info without password
      const { password, ...userWithoutPassword } = user;
      res.json({ user: userWithoutPassword, token });
    } catch (error) {
      console.error("Error registering user:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Données invalides", details: error.errors });
      } else {
        res.status(500).json({ error: "Erreur lors de l'inscription" });
      }
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = loginSchema.parse(req.body);
      
      // Find user by email
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(401).json({ error: "Email ou mot de passe incorrect" });
      }
      
      // Check password
      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        return res.status(401).json({ error: "Email ou mot de passe incorrect" });
      }
      
      // Generate JWT token
      const token = jwt.sign(
        { userId: user.id, email: user.email, username: user.username },
        JWT_SECRET,
        { expiresIn: '7d' }
      );
      
      // Return user info without password
      const { password: _, ...userWithoutPassword } = user;
      res.json({ user: userWithoutPassword, token });
    } catch (error) {
      console.error("Error logging in user:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Données invalides", details: error.errors });
      } else {
        res.status(500).json({ error: "Erreur lors de la connexion" });
      }
    }
  });

  app.post("/api/auth/logout", async (req, res) => {
    // In a real app, you might want to blacklist the token
    res.json({ message: "Déconnexion réussie" });
  });

  app.get("/api/auth/me", async (req: any, res: any) => {
    if (!req.user) {
      return res.status(401).json({ error: "Non authentifié" });
    }
    
    try {
      const user = await storage.getUserById(req.user.userId);
      if (!user) {
        return res.status(404).json({ error: "Utilisateur non trouvé" });
      }
      
      const { password, ...userWithoutPassword } = user;
      res.json({ user: userWithoutPassword });
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ error: "Erreur lors de la récupération de l'utilisateur" });
    }
  });
  
  // Get user favorites
  app.get("/api/favorites/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const favorites = await storage.getFavorites(userId);
      res.json(favorites);
    } catch (error) {
      console.error("Error fetching favorites:", error);
      res.status(500).json({ error: "Failed to fetch favorites" });
    }
  });

  // Add to favorites
  app.post("/api/favorites", async (req, res) => {
    try {
      const favoriteData = insertFavoriteSchema.parse(req.body);
      const favorite = await storage.addFavorite(favoriteData);
      res.json(favorite);
    } catch (error) {
      console.error("Error adding favorite:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid favorite data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to add favorite" });
      }
    }
  });

  // Remove from favorites
  app.delete("/api/favorites/:userId/:movieId", async (req, res) => {
    try {
      const { userId, movieId } = req.params;
      await storage.removeFavorite(userId, parseInt(movieId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing favorite:", error);
      res.status(500).json({ error: "Failed to remove favorite" });
    }
  });

  // Check if movie is favorite
  app.get("/api/favorites/:userId/:movieId", async (req, res) => {
    try {
      const { userId, movieId } = req.params;
      const isFavorite = await storage.isFavorite(userId, parseInt(movieId));
      res.json({ isFavorite });
    } catch (error) {
      console.error("Error checking favorite:", error);
      res.status(500).json({ error: "Failed to check favorite status" });
    }
  });

  // Get watch history
  app.get("/api/watch-history/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const history = await storage.getWatchHistory(userId);
      res.json(history);
    } catch (error) {
      console.error("Error fetching watch history:", error);
      res.status(500).json({ error: "Failed to fetch watch history" });
    }
  });

  // Add to watch history
  app.post("/api/watch-history", async (req, res) => {
    try {
      const historyData = insertWatchHistorySchema.parse(req.body);
      const history = await storage.addToWatchHistory(historyData);
      res.json(history);
    } catch (error) {
      console.error("Error adding to watch history:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid history data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to add to watch history" });
      }
    }
  });

  // Get user preferences
  app.get("/api/preferences/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const preferences = await storage.getUserPreferences(userId);
      res.json(preferences || { preferredGenres: [], language: "fr", autoplay: true });
    } catch (error) {
      console.error("Error fetching preferences:", error);
      res.status(500).json({ error: "Failed to fetch preferences" });
    }
  });

  // Update user preferences
  app.put("/api/preferences/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const preferencesData = insertUserPreferencesSchema.partial().parse(req.body);
      const preferences = await storage.updateUserPreferences(userId, preferencesData);
      res.json(preferences);
    } catch (error) {
      console.error("Error updating preferences:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid preferences data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update preferences" });
      }
    }
  });

  // Submit contact message
  app.post("/api/contact", async (req, res) => {
    try {
      const contactData = insertContactMessageSchema.parse(req.body);
      const message = await storage.createContactMessage(contactData);
      res.json({ success: true, message });
    } catch (error) {
      console.error("Error submitting contact message:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid contact data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to submit contact message" });
      }
    }
  });

  // Admin Routes
  app.get("/api/admin/users", requireAdmin, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      // Remove passwords from response
      const safeUsers = users.map(({ password, ...user }) => user);
      res.json(safeUsers);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

  app.get("/api/admin/favorites", requireAdmin, async (req, res) => {
    try {
      const favorites = await storage.getAllFavorites();
      res.json(favorites);
    } catch (error) {
      console.error("Error fetching all favorites:", error);
      res.status(500).json({ error: "Failed to fetch favorites" });
    }
  });

  app.delete("/api/contact-messages/:messageId", requireAdmin, async (req, res) => {
    try {
      const { messageId } = req.params;
      await storage.deleteContactMessage(messageId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting contact message:", error);
      res.status(500).json({ error: "Failed to delete message" });
    }
  });

  // Get contact messages (for admin purposes)
  app.get("/api/contact-messages", async (req, res) => {
    try {
      const messages = await storage.getContactMessages();
      res.json(messages);
    } catch (error) {
      console.error("Error fetching contact messages:", error);
      res.status(500).json({ error: "Failed to fetch contact messages" });
    }
  });

  // Admin user management routes
  app.put("/api/admin/users/:userId/suspend", requireAdmin, async (req: any, res: any) => {
    try {
      const { userId } = req.params;
      // In a real implementation, you would update user status in database
      res.json({ success: true, message: "Utilisateur suspendu" });
    } catch (error) {
      console.error("Error suspending user:", error);
      res.status(500).json({ error: "Failed to suspend user" });
    }
  });

  app.put("/api/admin/users/:userId/ban", requireAdmin, async (req: any, res: any) => {
    try {
      const { userId } = req.params;
      // In a real implementation, you would update user status in database
      res.json({ success: true, message: "Utilisateur banni" });
    } catch (error) {
      console.error("Error banning user:", error);
      res.status(500).json({ error: "Failed to ban user" });
    }
  });

  // Admin notification routes
  app.get("/api/admin/notifications", requireAdmin, async (req: any, res: any) => {
    try {
      const notifications = await storage.getAllNotifications();
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  app.post("/api/admin/notifications/send", requireAdmin, async (req: any, res: any) => {
    try {
      const { userId, title, message, type } = req.body;
      const notification = await storage.createNotification({
        userId,
        title: title || "Notification de l'administrateur",
        message,
        type: type || "info",
        read: false
      });
      res.json({ success: true, message: "Notification envoyée", notification });
    } catch (error) {
      console.error("Error sending notification:", error);
      res.status(500).json({ error: "Failed to send notification" });
    }
  });

  // Subscription management routes
  app.get("/api/admin/subscriptions", requireAdmin, async (req: any, res: any) => {
    try {
      const subscriptions = await storage.getSubscriptions();
      res.json(subscriptions);
    } catch (error) {
      console.error("Error fetching subscriptions:", error);
      res.status(500).json({ error: "Failed to fetch subscriptions" });
    }
  });

  app.put("/api/admin/users/:userId/subscription", requireAdmin, async (req: any, res: any) => {
    try {
      const { userId } = req.params;
      const { planId } = req.body;
      await storage.updateUserSubscriptionPlan(userId, planId);
      res.json({ success: true, message: "Plan d'abonnement mis à jour" });
    } catch (error) {
      console.error("Error updating subscription:", error);
      res.status(500).json({ error: "Failed to update subscription" });
    }
  });

  // Payment history routes
  app.get("/api/admin/payments", requireAdmin, async (req: any, res: any) => {
    try {
      const payments = await storage.getPayments();
      res.json(payments);
    } catch (error) {
      console.error("Error fetching payments:", error);
      res.status(500).json({ error: "Failed to fetch payments" });
    }
  });

  // Banner management routes
  app.get("/api/admin/banners", requireAdmin, async (req: any, res: any) => {
    try {
      const banners = await storage.getBanners();
      res.json(banners);
    } catch (error) {
      console.error("Error fetching banners:", error);
      res.status(500).json({ error: "Failed to fetch banners" });
    }
  });

  app.post("/api/admin/banners", requireAdmin, async (req: any, res: any) => {
    try {
      const bannerData = insertBannerSchema.parse(req.body);
      const banner = await storage.createBanner(bannerData);
      res.json({ success: true, message: "Bannière créée", banner });
    } catch (error) {
      console.error("Error creating banner:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid banner data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create banner" });
      }
    }
  });

  app.put("/api/admin/banners/:bannerId/toggle", requireAdmin, async (req: any, res: any) => {
    try {
      const { bannerId } = req.params;
      const banner = await storage.getBanners();
      const currentBanner = banner.find(b => b.id === bannerId);
      if (!currentBanner) {
        return res.status(404).json({ error: "Banner not found" });
      }
      await storage.updateBanner(bannerId, { active: !currentBanner.active });
      res.json({ success: true, message: "Statut de la bannière mis à jour" });
    } catch (error) {
      console.error("Error toggling banner:", error);
      res.status(500).json({ error: "Failed to toggle banner" });
    }
  });

  // Collections management routes
  app.get("/api/admin/collections", requireAdmin, async (req: any, res: any) => {
    try {
      const collections = await storage.getCollections();
      res.json(collections);
    } catch (error) {
      console.error("Error fetching collections:", error);
      res.status(500).json({ error: "Failed to fetch collections" });
    }
  });

  app.post("/api/admin/collections", requireAdmin, async (req: any, res: any) => {
    try {
      const collectionData = insertCollectionSchema.parse(req.body);
      const collection = await storage.createCollection(collectionData);
      res.json({ success: true, message: "Collection créée", collection });
    } catch (error) {
      console.error("Error creating collection:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid collection data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create collection" });
      }
    }
  });

  // Content management routes
  app.get("/api/admin/content", requireAdmin, async (req: any, res: any) => {
    try {
      const content = await storage.getContent();
      res.json(content);
    } catch (error) {
      console.error("Error fetching content:", error);
      res.status(500).json({ error: "Failed to fetch content" });
    }
  });

  app.post("/api/admin/content", requireAdmin, async (req: any, res: any) => {
    try {
      const contentData = insertContentSchema.parse(req.body);
      
      // Check if content with this TMDB ID already exists
      const existingContent = await storage.getContentByTmdbId(contentData.tmdbId);
      if (existingContent) {
        return res.status(400).json({ error: "Ce contenu existe déjà dans la plateforme" });
      }
      
      const content = await storage.createContent(contentData);
      res.json({ success: true, message: "Contenu ajouté", content });
    } catch (error) {
      console.error("Error creating content:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid content data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create content" });
      }
    }
  });

  app.put("/api/admin/content/:contentId", requireAdmin, async (req: any, res: any) => {
    try {
      const { contentId } = req.params;
      const contentData = insertContentSchema.partial().parse(req.body);
      const content = await storage.updateContent(contentId, contentData);
      res.json({ success: true, message: "Contenu mis à jour", content });
    } catch (error) {
      console.error("Error updating content:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid content data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update content" });
      }
    }
  });

  app.delete("/api/admin/content/:contentId", requireAdmin, async (req: any, res: any) => {
    try {
      const { contentId } = req.params;
      await storage.deleteContent(contentId);
      res.json({ success: true, message: "Contenu supprimé" });
    } catch (error) {
      console.error("Error deleting content:", error);
      res.status(500).json({ error: "Failed to delete content" });
    }
  });

  // Analytics and statistics routes
  app.get("/api/admin/analytics", requireAdmin, async (req: any, res: any) => {
    try {
      // Calculate real analytics from database with error handling
      let users: any[] = [];
      let subscriptions: any[] = [];
      let payments: any[] = [];
      let favorites: any[] = [];
      let activeSessions: any[] = [];
      let viewStats = { dailyViews: 0, weeklyViews: 0 };
      
      try {
        [users, subscriptions, payments, favorites, activeSessions, viewStats] = await Promise.all([
          storage.getAllUsers(),
          storage.getSubscriptions(),
          storage.getPayments(),
          storage.getAllFavorites(),
          storage.getActiveSessions(),
          storage.getViewStats()
        ]);
      } catch (dbError) {
        console.error("Database error in analytics:", dbError);
        // Continue with empty arrays/default values
      }
      
      const activeSubscriptions = subscriptions.filter(s => s.status === 'active');
      const subscriptionsByPlan = {
        basic: activeSubscriptions.filter(s => s.planId === 'basic').length,
        standard: activeSubscriptions.filter(s => s.planId === 'standard').length,
        premium: activeSubscriptions.filter(s => s.planId === 'premium').length
      };
      
      const monthlyRevenue = payments
        .filter(p => p.status === 'success' && 
          new Date(p.createdAt).getMonth() === new Date().getMonth())
        .reduce((sum, p) => sum + p.amount, 0);
      
      // Calculate unique movies and series from favorites
      const uniqueMovies = new Set(favorites.map(f => f.movieId)).size;
      
      // Calculate current month activity
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();
      
      const currentMonthPayments = payments.filter(p => {
        const paymentDate = new Date(p.createdAt);
        return paymentDate.getMonth() === currentMonth && 
               paymentDate.getFullYear() === currentYear;
      });
      
      // Calculate real revenue growth (comparing to previous month)
      const previousMonth = currentMonth === 0 ? 11 : currentMonth - 1;
      const previousYear = currentMonth === 0 ? currentYear - 1 : currentYear;
      
      const previousMonthRevenue = payments
        .filter(p => {
          const paymentDate = new Date(p.createdAt);
          return p.status === 'success' &&
                 paymentDate.getMonth() === previousMonth && 
                 paymentDate.getFullYear() === previousYear;
        })
        .reduce((sum, p) => sum + p.amount, 0);
      
      const growthPercentage = previousMonthRevenue > 0 
        ? Math.round(((monthlyRevenue - previousMonthRevenue) / previousMonthRevenue) * 100)
        : 0;
      
      // Recent users (registered in the last 7 days)
      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
      const newUsersThisWeek = users.filter(u => new Date(u.createdAt) >= oneWeekAgo).length;
      
      // Active subscriptions count
      const activeSubscriptionsCount = activeSubscriptions.length;
      
      // Real active users from current sessions
      const realActiveUsers = activeSessions.filter(session => {
        const sessionAge = Date.now() - new Date(session.sessionStart).getTime();
        return sessionAge < 30 * 60 * 1000; // Active in last 30 minutes
      }).length;
      
      const analytics = {
        totalUsers: users.length,
        activeUsers: Math.max(realActiveUsers, users.filter(u => u.role === 'user').length),
```

```

```
